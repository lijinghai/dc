var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// node_modules/.pnpm/tsup@5.11.9_typescript@4.5.4/node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "node_modules/.pnpm/tsup@5.11.9_typescript@4.5.4/node_modules/tsup/assets/cjs_shims.js"() {
  }
});

// node_modules/.pnpm/is-unicode-supported@0.1.0/node_modules/is-unicode-supported/index.js
var require_is_unicode_supported = __commonJS({
  "node_modules/.pnpm/is-unicode-supported@0.1.0/node_modules/is-unicode-supported/index.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = () => {
      if (process.platform !== "win32") {
        return true;
      }
      return Boolean(process.env.CI) || Boolean(process.env.WT_SESSION) || process.env.TERM_PROGRAM === "vscode" || process.env.TERM === "xterm-256color" || process.env.TERM === "alacritty";
    };
  }
});

// node_modules/.pnpm/log-symbols@4.1.0/node_modules/log-symbols/index.js
var require_log_symbols = __commonJS({
  "node_modules/.pnpm/log-symbols@4.1.0/node_modules/log-symbols/index.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    var chalk = require("chalk");
    var isUnicodeSupported = require_is_unicode_supported();
    var main2 = {
      info: chalk.blue("\u2139"),
      success: chalk.green("\u2714"),
      warning: chalk.yellow("\u26A0"),
      error: chalk.red("\u2716")
    };
    var fallback = {
      info: chalk.blue("i"),
      success: chalk.green("\u221A"),
      warning: chalk.yellow("\u203C"),
      error: chalk.red("\xD7")
    };
    module2.exports = isUnicodeSupported() ? main2 : fallback;
  }
});

// node_modules/.pnpm/detect-newline@3.1.0/node_modules/detect-newline/index.js
var require_detect_newline = __commonJS({
  "node_modules/.pnpm/detect-newline@3.1.0/node_modules/detect-newline/index.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    var detectNewline2 = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      const newlines = string.match(/(?:\r?\n)/g) || [];
      if (newlines.length === 0) {
        return;
      }
      const crlf = newlines.filter((newline) => newline === "\r\n").length;
      const lf = newlines.length - crlf;
      return crlf > lf ? "\r\n" : "\n";
    };
    module2.exports = detectNewline2;
    module2.exports.graceful = (string) => typeof string === "string" && detectNewline2(string) || "\n";
  }
});

// src/cli/index.ts
var cli_exports = {};
__export(cli_exports, {
  main: () => main
});
init_cjs_shims();
var import_log_symbols2 = __toESM(require_log_symbols());

// package.json
var name = "bumpp";
var version = "7.2.0";
var description = "Automatically (or with prompts) bump your version number, commit changes, tag, and push to Git";

// src/types/version-bump-progress.ts
init_cjs_shims();
var ProgressEvent = /* @__PURE__ */ ((ProgressEvent2) => {
  ProgressEvent2["FileUpdated"] = "file updated";
  ProgressEvent2["FileSkipped"] = "file skipped";
  ProgressEvent2["GitCommit"] = "git commit";
  ProgressEvent2["GitTag"] = "git tag";
  ProgressEvent2["GitPush"] = "git push";
  ProgressEvent2["NpmScript"] = "npm script";
  return ProgressEvent2;
})(ProgressEvent || {});
var NpmScript = /* @__PURE__ */ ((NpmScript3) => {
  NpmScript3["PreVersion"] = "preversion";
  NpmScript3["Version"] = "version";
  NpmScript3["PostVersion"] = "postversion";
  return NpmScript3;
})(NpmScript || {});

// src/version-bump.ts
init_cjs_shims();
var ezSpawn3 = __toESM(require("@jsdevtools/ez-spawn"));

// src/get-new-version.ts
init_cjs_shims();
var import_chalk = require("chalk");
var import_prompts = __toESM(require("prompts"));
var import_semver2 = require("semver");
var import_semver3 = __toESM(require("semver"));

// src/release-type.ts
init_cjs_shims();
var import_semver = require("semver");
var prereleaseTypes = ["prerelease"];
var releaseTypes = prereleaseTypes.concat(["major", "minor", "patch"]);
function isPrerelease(value) {
  return prereleaseTypes.includes(value);
}
function isReleaseType(value) {
  return releaseTypes.includes(value);
}

// src/get-new-version.ts
async function getNewVersion(operation) {
  let { release } = operation.options;
  let { oldVersion } = operation.state;
  switch (release.type) {
    case "prompt":
      return promptForNewVersion(operation);
    case "version":
      let newSemVer = new import_semver3.SemVer(release.version, true);
      return operation.update({
        newVersion: newSemVer.version
      });
    default:
      return operation.update({
        release: release.type,
        newVersion: getNextVersion(oldVersion, release)
      });
  }
}
function getNextVersion(oldVersion, bump) {
  let oldSemVer = new import_semver3.SemVer(oldVersion);
  let newSemVer = oldSemVer.inc(bump.type, bump.preid);
  if (isPrerelease(bump.type) && newSemVer.prerelease.length === 2 && newSemVer.prerelease[0] === bump.preid && String(newSemVer.prerelease[1]) === "0") {
    newSemVer.prerelease[1] = "1";
    newSemVer.format();
  }
  return newSemVer.version;
}
function getNextVersions(oldVersion, preid) {
  var _a;
  let next = {};
  const parse = import_semver3.default.parse(oldVersion);
  if (typeof (parse == null ? void 0 : parse.prerelease[0]) === "string") {
    preid = (parse == null ? void 0 : parse.prerelease[0]) || "preid";
  }
  for (let type of releaseTypes) {
    next[type] = import_semver3.default.inc(oldVersion, type, preid);
  }
  next.next = ((_a = parse == null ? void 0 : parse.prerelease) == null ? void 0 : _a.length) ? import_semver3.default.inc(oldVersion, "prerelease", preid) : import_semver3.default.inc(oldVersion, "patch");
  return next;
}
async function promptForNewVersion(operation) {
  let { oldVersion } = operation.state;
  let release = operation.options.release;
  let next = getNextVersions(oldVersion, release.preid);
  let answers;
  answers = await (0, import_prompts.default)([
    {
      type: "autocomplete",
      name: "release",
      message: `Current version: ${(0, import_chalk.green)(oldVersion)}`,
      initial: "next",
      choices: [
        { value: "major", title: "major - " + (0, import_chalk.bold)(next.major) },
        { value: "minor", title: "minor - " + (0, import_chalk.bold)(next.minor) },
        { value: "patch", title: "patch - " + (0, import_chalk.bold)(next.patch) },
        { value: "next", title: "next - " + (0, import_chalk.bold)(next.next) },
        { value: "prerelease", title: "pre-release - " + (0, import_chalk.bold)(next.prerelease) },
        { value: "none", title: "as-is - " + (0, import_chalk.bold)(oldVersion) },
        { value: "custom", title: "custom..." }
      ]
    },
    {
      type: (prev) => prev === "custom" ? "text" : null,
      name: "custom",
      message: "Enter the new version number:",
      initial: oldVersion,
      validate: (custom) => {
        return (0, import_semver2.valid)(custom) ? true : "That's not a valid version number";
      }
    }
  ]);
  const newVersion = answers.release === "none" ? oldVersion : answers.release === "custom" ? (0, import_semver2.clean)(answers.custom) : next[answers.release];
  if (!newVersion) {
    process.exit(1);
  }
  switch (answers.release) {
    case "custom":
    case "none":
      return operation.update({ newVersion });
    default:
      return operation.update({ release: answers.release, newVersion });
  }
}

// src/get-old-version.ts
init_cjs_shims();
var import_semver4 = require("semver");

// src/fs.ts
init_cjs_shims();

// node_modules/.pnpm/detect-indent@7.0.0/node_modules/detect-indent/index.js
init_cjs_shims();
var INDENT_REGEX = /^(?:( )+|\t+)/;
var INDENT_TYPE_SPACE = "space";
var INDENT_TYPE_TAB = "tab";
function makeIndentsMap(string, ignoreSingleSpaces) {
  const indents = /* @__PURE__ */ new Map();
  let previousSize = 0;
  let previousIndentType;
  let key;
  for (const line of string.split(/\n/g)) {
    if (!line) {
      continue;
    }
    let indent;
    let indentType;
    let weight;
    let entry;
    const matches = line.match(INDENT_REGEX);
    if (matches === null) {
      previousSize = 0;
      previousIndentType = "";
    } else {
      indent = matches[0].length;
      indentType = matches[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;
      if (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {
        continue;
      }
      if (indentType !== previousIndentType) {
        previousSize = 0;
      }
      previousIndentType = indentType;
      weight = 0;
      const indentDifference = indent - previousSize;
      previousSize = indent;
      if (indentDifference === 0) {
        weight++;
      } else {
        const absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;
        key = encodeIndentsKey(indentType, absoluteIndentDifference);
      }
      entry = indents.get(key);
      entry = entry === void 0 ? [1, 0] : [++entry[0], entry[1] + weight];
      indents.set(key, entry);
    }
  }
  return indents;
}
function encodeIndentsKey(indentType, indentAmount) {
  const typeCharacter = indentType === INDENT_TYPE_SPACE ? "s" : "t";
  return typeCharacter + String(indentAmount);
}
function decodeIndentsKey(indentsKey) {
  const keyHasTypeSpace = indentsKey[0] === "s";
  const type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;
  const amount = Number(indentsKey.slice(1));
  return { type, amount };
}
function getMostUsedKey(indents) {
  let result;
  let maxUsed = 0;
  let maxWeight = 0;
  for (const [key, [usedCount, weight]] of indents) {
    if (usedCount > maxUsed || usedCount === maxUsed && weight > maxWeight) {
      maxUsed = usedCount;
      maxWeight = weight;
      result = key;
    }
  }
  return result;
}
function makeIndentString(type, amount) {
  const indentCharacter = type === INDENT_TYPE_SPACE ? " " : "	";
  return indentCharacter.repeat(amount);
}
function detectIndent(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  let indents = makeIndentsMap(string, true);
  if (indents.size === 0) {
    indents = makeIndentsMap(string, false);
  }
  const keyOfMostUsedIndent = getMostUsedKey(indents);
  let type;
  let amount = 0;
  let indent = "";
  if (keyOfMostUsedIndent !== void 0) {
    ({ type, amount } = decodeIndentsKey(keyOfMostUsedIndent));
    indent = makeIndentString(type, amount);
  }
  return {
    amount,
    type,
    indent
  };
}

// src/fs.ts
var import_detect_newline = __toESM(require_detect_newline());
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
async function readJsonFile(name2, cwd) {
  let file = await readTextFile(name2, cwd);
  let data = JSON.parse(file.data);
  let indent = detectIndent(file.data).indent;
  let newline = (0, import_detect_newline.default)(file.data);
  return __spreadProps(__spreadValues({}, file), { data, indent, newline });
}
async function writeJsonFile(file) {
  let json = JSON.stringify(file.data, void 0, file.indent);
  if (file.newline) {
    json += file.newline;
  }
  return writeTextFile(__spreadProps(__spreadValues({}, file), { data: json }));
}
function readTextFile(name2, cwd) {
  return new Promise((resolve, reject) => {
    let filePath = import_path.default.join(cwd, name2);
    import_fs.default.readFile(filePath, "utf8", (err, text) => {
      if (err) {
        reject(err);
      } else {
        resolve({
          path: filePath,
          data: text
        });
      }
    });
  });
}
function writeTextFile(file) {
  return new Promise((resolve, reject) => {
    import_fs.default.writeFile(file.path, file.data, (err) => {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
}

// src/manifest.ts
init_cjs_shims();
function isManifest(obj) {
  return obj && typeof obj === "object" && isOptionalString(obj.name) && isOptionalString(obj.version) && isOptionalString(obj.description);
}
function isOptionalString(value) {
  let type = typeof value;
  return value === null || type === "undefined" || type === "string";
}

// src/get-old-version.ts
async function getOldVersion(operation) {
  let { cwd, files } = operation.options;
  let filesToCheck = files.filter((file) => file.endsWith(".json"));
  if (!filesToCheck.includes("package.json")) {
    filesToCheck.push("package.json");
  }
  for (let file of filesToCheck) {
    let version2 = await readVersion(file, cwd);
    if (version2) {
      return operation.update({
        oldVersionSource: file,
        oldVersion: version2
      });
    }
  }
  throw new Error(`Unable to determine the current version number. Checked ${filesToCheck.join(", ")}.`);
}
async function readVersion(file, cwd) {
  try {
    let { data: manifest } = await readJsonFile(file, cwd);
    if (isManifest(manifest)) {
      if ((0, import_semver4.valid)(manifest.version)) {
        return manifest.version;
      }
    }
  } catch (error) {
    return void 0;
  }
}

// src/git.ts
init_cjs_shims();
var ezSpawn = __toESM(require("@jsdevtools/ez-spawn"));
async function gitCommit(operation) {
  if (!operation.options.commit) {
    return operation;
  }
  let { all, noVerify, message } = operation.options.commit;
  let { updatedFiles, newVersion } = operation.state;
  let args = [];
  if (all) {
    args.push("--all");
  }
  if (noVerify) {
    args.push("--no-verify");
  }
  let commitMessage = formatVersionString(message, newVersion);
  args.push("--message", commitMessage);
  if (!all) {
    args = args.concat(updatedFiles);
  }
  await ezSpawn.async("git", ["commit", ...args]);
  return operation.update({ event: "git commit" /* GitCommit */, commitMessage });
}
async function gitTag(operation) {
  if (!operation.options.tag) {
    return operation;
  }
  let { commit, tag } = operation.options;
  let { newVersion } = operation.state;
  let args = [
    "--annotate",
    "--message",
    formatVersionString(commit.message, newVersion)
  ];
  let tagName = formatVersionString(tag.name, newVersion);
  args.push(tagName);
  await ezSpawn.async("git", ["tag", ...args]);
  return operation.update({ event: "git tag" /* GitTag */, tagName });
}
async function gitPush(operation) {
  if (!operation.options.push) {
    return operation;
  }
  await ezSpawn.async("git", "push");
  if (operation.options.tag) {
    await ezSpawn.async("git", ["push", "--tags"]);
  }
  return operation.update({ event: "git push" /* GitPush */ });
}
function formatVersionString(template, newVersion) {
  if (template.includes("%s")) {
    return template.replace(/%s/g, newVersion);
  } else {
    return template + newVersion;
  }
}

// src/operation.ts
init_cjs_shims();

// src/normalize-options.ts
init_cjs_shims();
var import_globby = __toESM(require("globby"));
var import_globby2 = require("globby");
async function normalizeOptions(raw) {
  let preid = typeof raw.preid === "string" ? raw.preid : "beta";
  let push = Boolean(raw.push);
  let all = Boolean(raw.all);
  let noVerify = Boolean(raw.noVerify);
  let cwd = raw.cwd || process.cwd();
  let ignoreScripts = Boolean(raw.ignoreScripts);
  let execute = raw.execute;
  let release;
  if (!raw.release || raw.release === "prompt") {
    release = { type: "prompt", preid };
  } else if (isReleaseType(raw.release)) {
    release = { type: raw.release, preid };
  } else {
    release = { type: "version", version: raw.release };
  }
  let tag;
  if (typeof raw.tag === "string") {
    tag = { name: raw.tag };
  } else if (raw.tag) {
    tag = { name: "v" };
  }
  let commit;
  if (typeof raw.commit === "string") {
    commit = { all, noVerify, message: raw.commit };
  } else if (raw.commit || tag || push) {
    commit = { all, noVerify, message: "release v" };
  }
  let files;
  if (Array.isArray(raw.files) && raw.files.length > 0) {
    files = await strictGlobMatches(raw.files, { cwd });
  } else {
    files = await (0, import_globby.default)(["package.json", "package-lock.json"], { cwd });
  }
  let ui;
  if (raw.interface === false) {
    ui = { input: false, outut: false };
  } else if (raw.interface === true || !raw.interface) {
    ui = { input: process.stdin, output: process.stdout };
  } else {
    let _a = raw.interface, { input, output } = _a, other = __objRest(_a, ["input", "output"]);
    if (input === true || input !== false && !input) {
      input = process.stdin;
    }
    if (output === true || output !== false && !output) {
      output = process.stdout;
    }
    ui = __spreadValues({ input, output }, other);
  }
  if (release.type === "prompt" && !(ui.input && ui.output)) {
    throw new Error("Cannot prompt for the version number because input or output has been disabled.");
  }
  return { release, commit, tag, push, files, cwd, interface: ui, ignoreScripts, execute };
}
async function strictGlobMatches(files, options) {
  let matches = await Promise.all(files.map((file) => strictGlobMatch(file, options)));
  let matchedFiles = /* @__PURE__ */ new Set();
  for (let match of matches) {
    for (let file of match) {
      matchedFiles.add(file);
    }
  }
  return [...matchedFiles];
}
async function strictGlobMatch(file, options) {
  let matches = await (0, import_globby.default)(file, options);
  if (matches.length === 0) {
    if ((0, import_globby2.hasMagic)(file)) {
      throw new Error(`Could not find any files matching "${file}".`);
    } else {
      throw new Error(`Could not find file: ${file}.`);
    }
  }
  return matches.sort();
}

// src/operation.ts
var Operation = class {
  constructor(options, progress2) {
    this.state = {
      release: void 0,
      oldVersion: "",
      oldVersionSource: "",
      newVersion: "",
      commitMessage: "",
      tagName: "",
      updatedFiles: [],
      skippedFiles: []
    };
    this.options = options;
    this._progress = progress2;
  }
  get results() {
    let options = this.options;
    let state = this.state;
    return {
      release: state.release,
      oldVersion: state.oldVersion,
      newVersion: state.newVersion,
      commit: options.commit ? state.commitMessage : false,
      tag: options.tag ? state.tagName : false,
      updatedFiles: state.updatedFiles.slice(),
      skippedFiles: state.skippedFiles.slice()
    };
  }
  static async start(input) {
    let options = await normalizeOptions(input);
    return new Operation(options, input.progress);
  }
  update(_a) {
    var _b = _a, { event, script } = _b, newState = __objRest(_b, ["event", "script"]);
    Object.assign(this.state, newState);
    if (event && this._progress) {
      this._progress(__spreadValues({ event, script }, this.results));
    }
    return this;
  }
};

// src/run-npm-script.ts
init_cjs_shims();
var ezSpawn2 = __toESM(require("@jsdevtools/ez-spawn"));
async function runNpmScript(script, operation) {
  let { cwd, ignoreScripts } = operation.options;
  if (!ignoreScripts) {
    let { data: manifest } = await readJsonFile("package.json", cwd);
    if (isManifest(manifest) && hasScript(manifest, script)) {
      await ezSpawn2.async("npm", ["run", script, "--silent"], { stdio: "inherit" });
      operation.update({ event: "npm script" /* NpmScript */, script });
    }
  }
  return operation;
}
function hasScript(manifest, script) {
  let scripts = manifest.scripts;
  if (scripts && typeof scripts === "object") {
    return Boolean(scripts[script]);
  }
  return false;
}

// src/update-files.ts
init_cjs_shims();
var path2 = __toESM(require("path"));
async function updateFiles(operation) {
  let { files } = operation.options;
  for (let relPath of files) {
    let modified = await updateFile(relPath, operation);
    if (modified) {
      operation.update({
        event: "file updated" /* FileUpdated */,
        updatedFiles: operation.state.updatedFiles.concat(relPath)
      });
    } else {
      operation.update({
        event: "file skipped" /* FileSkipped */,
        skippedFiles: operation.state.skippedFiles.concat(relPath)
      });
    }
  }
  return operation;
}
async function updateFile(relPath, operation) {
  let name2 = path2.basename(relPath).trim().toLowerCase();
  switch (name2) {
    case "package.json":
    case "package-lock.json":
    case "bower.json":
    case "component.json":
      return updateManifestFile(relPath, operation);
    default:
      return updateTextFile(relPath, operation);
  }
}
async function updateManifestFile(relPath, operation) {
  let { cwd } = operation.options;
  let { newVersion } = operation.state;
  let modified = false;
  let file = await readJsonFile(relPath, cwd);
  if (isManifest(file.data) && file.data.version !== newVersion) {
    file.data.version = newVersion;
    await writeJsonFile(file);
    modified = true;
  }
  return modified;
}
async function updateTextFile(relPath, operation) {
  let { cwd } = operation.options;
  let { oldVersion, newVersion } = operation.state;
  let modified = false;
  let file = await readTextFile(relPath, cwd);
  if (file.data.includes(oldVersion)) {
    let sanitizedVersion = oldVersion.replace(/(\W)/g, "\\$1");
    let replacePattern = new RegExp("(\\b|v)" + sanitizedVersion + "\\b", "g");
    file.data = file.data.replace(replacePattern, "$1" + newVersion);
    await writeTextFile(file);
    return true;
  }
  return modified;
}

// src/version-bump.ts
var import_log_symbols = __toESM(require_log_symbols());
async function versionBump(arg = {}) {
  if (typeof arg === "string") {
    arg = { release: arg };
  }
  let operation = await Operation.start(arg);
  await getOldVersion(operation);
  await getNewVersion(operation);
  await runNpmScript("preversion" /* PreVersion */, operation);
  await updateFiles(operation);
  if (operation.options.execute) {
    console.log(import_log_symbols.info, "Executing script", operation.options.execute);
    await ezSpawn3.async(operation.options.execute, { stdio: "inherit" });
    console.log(import_log_symbols.success, "Script finished");
  }
  await runNpmScript("version" /* Version */, operation);
  await gitCommit(operation);
  await gitTag(operation);
  await runNpmScript("postversion" /* PostVersion */, operation);
  await gitPush(operation);
  return operation.results;
}

// src/cli/exit-code.ts
init_cjs_shims();
var ExitCode = /* @__PURE__ */ ((ExitCode2) => {
  ExitCode2[ExitCode2["Success"] = 0] = "Success";
  ExitCode2[ExitCode2["FatalError"] = 1] = "FatalError";
  ExitCode2[ExitCode2["InvalidArgument"] = 9] = "InvalidArgument";
  return ExitCode2;
})(ExitCode || {});

// src/cli/help.ts
init_cjs_shims();
var usageText = `
Usage: bumpp [release] [options] [files...]

release:
  The release version or type.  Can be one of the following:
   - A semver version number (ex: 1.23.456)
   - prompt: Prompt for the version number (this is the default)
   - major: Increase major version
   - minor: Increase minor version
   - patch: Increase patch version
   - premajor: Increase major version, pre-release
   - preminor: Increase preminor version, pre-release
   - prepatch: Increase prepatch version, pre-release
   - prerelease: Increase prerelease version

options:
  --preid <name>            The identifier for prerelease versions.
                            Defaults to "beta".

  -c, --commit [message]    Commit changed files to Git.
                            Defaults to "release vX.X.X".

  -t, --tag [tag]           Tag the commit in Git.
                            The Default tag is "vX.X.X"

  -p, --push                Push the Git commit.

  -a, --all                 Commit/tag/push ALL pending files,
                            not just the ones that were bumped.
                            (same as "git commit -a")

  --no-verify               Bypass Git commit hooks
                            (same as "git commit --no-verify")

  -v, --version             Show the version number

  -x, --execute             Excute additional command after bumping and before commiting

  -q, --quiet               Suppress unnecessary output

  -h, --help                Show usage information

  --ignore-scripts          Bypass version scripts

files...
  One or more files and/or globs to bump (ex: README.md *.txt docs/**/*).
  Defaults to package.json and package-lock.json.

Examples:

  bumpp patch

    Bumps the patch version number in package.json and package-lock.json.
    Nothing is committed to git.

  bumpp major --commit

    Bumps the major version number in package.json and package-lock.json.
    Commits package.json and package-lock.json to git, but does not tag the commit.

  bumpp -tpa README.md

    Prompts for the new version number and updates package.json, package-lock.json, and README.md.
    Commits ALL modified files to git, tags the commit, and pushes the commit.

  bumpp 4.27.9934 --tag "Version " bower.json docs/**/*.md

    Sets the version number to 4.27.9934 in package.json, package-lock.json, bower.json,
    and all markdown files in the "docs" directory.  Commits the updated files to git,
    and tags the commit as "Version 4.27.9934".
`;
var helpText = `
${name} v${version} - ${description}
${usageText}`;

// src/cli/parse-args.ts
init_cjs_shims();
var import_command_line_args = __toESM(require("command-line-args"));
var import_semver5 = require("semver");
function parseArgs(argv) {
  try {
    let args = (0, import_command_line_args.default)([
      { name: "preid", type: String },
      { name: "commit", alias: "c", type: String },
      { name: "tag", alias: "t", type: String },
      { name: "push", alias: "p", type: Boolean },
      { name: "all", alias: "a", type: Boolean },
      { name: "no-verify", type: Boolean },
      { name: "quiet", alias: "q", type: Boolean },
      { name: "version", alias: "v", type: Boolean },
      { name: "help", alias: "h", type: Boolean },
      { name: "ignore-scripts", type: Boolean },
      { name: "execute", alias: "x", type: String },
      { name: "files", type: String, multiple: true, defaultOption: true }
    ], { argv });
    let parsedArgs = {
      help: args.help,
      version: args.version,
      quiet: args.quiet,
      options: {
        preid: args.preid,
        commit: args.commit,
        tag: args.tag,
        push: args.push,
        all: args.all,
        noVerify: args["no-verify"],
        files: args.files,
        ignoreScripts: args["ignore-scripts"],
        execute: args.execute
      }
    };
    if (args.preid === null) {
      throw new Error('The --preid option requires a value, such as "alpha", "beta", etc.');
    }
    if (args.commit === null) {
      parsedArgs.options.commit = true;
    }
    if (args.tag === null) {
      parsedArgs.options.tag = true;
    }
    if (parsedArgs.options.files && parsedArgs.options.files.length > 0) {
      let firstArg = parsedArgs.options.files[0];
      if (firstArg === "prompt" || isReleaseType(firstArg) || (0, import_semver5.valid)(firstArg)) {
        parsedArgs.options.release = firstArg;
        parsedArgs.options.files.shift();
      }
    }
    return parsedArgs;
  } catch (error) {
    return errorHandler(error);
  }
}
function errorHandler(error) {
  console.error(error.message);
  console.error(usageText);
  return process.exit(9 /* InvalidArgument */);
}

// src/cli/index.ts
async function main(args) {
  try {
    process.on("uncaughtException", errorHandler2);
    process.on("unhandledRejection", errorHandler2);
    let { help, version: version2, quiet, options } = parseArgs(args);
    if (help) {
      console.log(helpText);
      process.exit(0 /* Success */);
    } else if (version2) {
      console.log(version);
      process.exit(0 /* Success */);
    } else {
      if (!quiet) {
        options.progress = progress;
      }
      await versionBump(options);
    }
  } catch (error) {
    errorHandler2(error);
  }
}
function progress({ event, script, updatedFiles, skippedFiles, newVersion }) {
  switch (event) {
    case "file updated" /* FileUpdated */:
      console.log(import_log_symbols2.success, `Updated ${updatedFiles.pop()} to ${newVersion}`);
      break;
    case "file skipped" /* FileSkipped */:
      console.log(import_log_symbols2.info, `${skippedFiles.pop()} did not need to be updated`);
      break;
    case "git commit" /* GitCommit */:
      console.log(import_log_symbols2.success, "Git commit");
      break;
    case "git tag" /* GitTag */:
      console.log(import_log_symbols2.success, "Git tag");
      break;
    case "git push" /* GitPush */:
      console.log(import_log_symbols2.success, "Git push");
      break;
    case "npm script" /* NpmScript */:
      console.log(import_log_symbols2.success, `Npm run ${script}`);
      break;
  }
}
function errorHandler2(error) {
  let message = error.message || String(error);
  if (process.env.DEBUG || process.env.NODE_ENV === "development") {
    message = error.stack || message;
  }
  console.error(message);
  process.exit(1 /* FatalError */);
}
module.exports = __toCommonJS(cli_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  main
});
